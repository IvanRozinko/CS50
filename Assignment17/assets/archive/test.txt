From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

From the containers of the last week, the iterator MyLinkedList
was refined, which, while finding the next element, does not use
its get method, but uses the finding of the next element by the linked list method.

The queue structure is altered which is based on a single-linked list and stores
 only the link to the next element. But this structure is used only in MyHashMap
 and has not been redone for previous containers for 16 weekssince it is necessary to
 redo the structure of Node and complicate the number of files in the current project.

 The main difficulties in translating into their collections are as follows:
 - when creating a priority queue when the queue size after multiple extraction
  became zero, then the new array that was created had a size (size * 2)
  and since 0 * 2 = 0 an error message was displayed. To fix this bug, a new array
  structure with the size [size * 2 + 1] was invented, which solved this problem.
- also when creating MyHashMap and determining the cell number into which you want to
 put an element, the invented formula (hash% length) did not work for keys that have
  a negative value, for example, keys that are Byte, therefore a fix was made
  (Math.abs (hash)% length) to take the modulus of the number and therefore the cell
  index will always be positive.
- the created iterator MyHashMap works and returns the value of the following element,
 but since the array may contain empty cells it was not possible to remove them
  during the output. The problem is solved by additional checking if (key! = Null).

Performance slipped a bit and managed to verify this when archiving data, but not significantly.

PriorityQueue is based on the principle of creating an expandable array which, each time
a new element is added, sorts a given array and at the end of the array always contains
the element with the lowest value. When the element is found out, the last element is
extracted and the size of the array is changed.

Since the writing of the HashMap is based on the use of the extended queue array
(a single-linked list), when the same hash for the keys is found in my queue, a method
is invented that checks whether the given element is in the queue and compares its hash
and key value. And if a key with such a value is already in the queue, the value that
corresponds to the key is replaced.

Since PriorityQueue is not built on a binary heap, it is based on the array that is not.
For MyArrayList, an iterator is not invented, since any cycle can cope with a detour.

v
